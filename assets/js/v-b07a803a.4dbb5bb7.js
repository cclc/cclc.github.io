"use strict";(self.webpackChunkcclc_vuepress=self.webpackChunkcclc_vuepress||[]).push([[1744],{604:(e,a,s)=>{s.r(a),s.d(a,{data:()=>r});const r={key:"v-b07a803a",path:"/frontend/browser-cors.html",title:"通过浏览器解决跨域问题",lang:"zh-CN",frontmatter:{title:"通过浏览器解决跨域问题",date:"2019-03-26",categories:["Other"],tags:["CORS"]},excerpt:"",headers:[],git:{},filePathRelative:"frontend/browser-cors.md"}},8141:(e,a,s)=>{s.r(a),s.d(a,{default:()=>t});const r=(0,s(6252).uE)('<h1 id="通过浏览器解决跨域问题" tabindex="-1"><a class="header-anchor" href="#通过浏览器解决跨域问题" aria-hidden="true">#</a> 通过浏览器解决跨域问题</h1><p><strong>跨域本质上是浏览器的安全设置，前端和后台的域名或端口不一样的情况下，浏览器会先发送一个 option 请求验证后台是否允许跨域。如果验证通过则发送正常的请求，如果不通过返回 403 错误信息，提示后台禁止跨域。</strong></p><p>解决跨域问题有两种思路：</p><ol><li><p>在后台代码加上 cors 协议的代码。 但是在生产环境中，如果前端和后台在同一服务器上的情况下，为了安全性最好去掉跨域代码。 这就造成在需要在发布时增加去掉跨域代码的操作，有点麻烦。</p></li><li><p>从浏览器入手，以 MAC 的 Chrome 浏览器为例： 先新建一个文件夹，之后在 terminal 里用命令启动禁止了网络安全的 Chrome。</p></li></ol><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">open</span> <span class="token parameter variable">-n</span> /Applications/Google<span class="token punctuation">\\</span> Chrome.app/ <span class="token parameter variable">--args</span> --disable-web-security --user-data-dir<span class="token operator">=</span>/Users/username/Documents/MyChromeDevUserData\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样也可以在本地跑前端代码调试服务器上的后台数据了。</p>',6),n={},t=(0,s(3744).Z)(n,[["render",function(e,a){return r}]])},3744:(e,a)=>{a.Z=(e,a)=>{const s=e.__vccOpts||e;for(const[e,r]of a)s[e]=r;return s}}}]);